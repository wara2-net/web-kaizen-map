<!DOCTYPE html>
<html>

<head>
  <base target="_top">
</head>

<body>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
    integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
    integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>

  <!-- https://moewe-net.com/js/leaflet マーカークラスターのためのscript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.js"
    integrity="sha512-OFs3W4DIZ5ZkrDhBFtsCP6JXtMEDGmhl0QPlmWYBJay40TT1n3gt2Xuw8Pf/iezgW9CdabjkNChRqozl/YADmg=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.min.css"
    integrity="sha512-ENrTWqddXrLJsQS2A86QmvA17PkJ0GVm1bqj5aTgpeMAfDKN2+SIOLpKG8R/6KkimnhTb+VW5qqUHB/r1zaRgg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.min.css"
    integrity="sha512-fYyZwU1wU0QWB4Yutd/Pvhy5J1oWAwFXun1pt+Bps04WSe4Aq6tyHlT4+MHSJhD8JlLfgLuC4CbCnX5KHSjyCg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />

  <style type="text/css">
    /* アイコンの色変えるのに必要 */
    .icon-blue {
      filter: hue-rotate(0deg);
    }

    .icon-red {
      filter: hue-rotate(150deg);
    }

    .icon-yellow {
      filter: hue-rotate(225deg) brightness(200%);
    }

    .icon-green {
      filter: hue-rotate(270deg) brightness(150%);
    }

    .icon-orange {
      filter: hue-rotate(165deg) brightness(150%);
    }

    .icon-gray {
      filter: grayscale(100%);
    }

    .legend-item {
      display: flex;
      align-items: center;
      color: #555;
    }

    .legend-item-color {
      display: block;
      width: 15px;
      height: 15px;
      margin-right: 5px;
    }
  </style>

  <script>
    window.onload = function () {
      refreshMap();
    };

    //https://qiita.com/access3151fq/items/ffdd74fdb3468d29e553
    //アイコンの色を変える
    function genIconObject(colorClassName) {
      return L.icon({
        iconUrl: "https://esm.sh/leaflet@1.9.2/dist/images/marker-icon.png",
        iconRetinaUrl: "https://esm.sh/leaflet@1.9.2/dist/images/marker-icon-2x.png",
        shadowUrl: "https://esm.sh/leaflet@1.9.2/dist/images/marker-shadow.png",
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34],
        tooltipAnchor: [16, -28], shadowSize: [41, 41],
        className: colorClassName, // <= ここでcssで作ったクラス名を指定
      });
    }
    const mapIcons = {
      "redIcon":    genIconObject("icon-red"),
      "blueIcon":   genIconObject("icon-blue"),
      "yellowIcon": genIconObject("icon-yellow"),
      "greenIcon":  genIconObject("icon-green"),
      "orangeIcon": genIconObject("icon-orange"),
      "grayIcon":   genIconObject("icon-gray")
    };

    // // 20260209 JQueryを使わない関数に変更(ライブラリ読込をコメントアウト)
    //JSONを取ってきてparseしたものを返す関数
    async function getParsedJSON(jsonURL) {
      try{
        const response = await fetch(jsonURL);
        if (!response.ok) {
          console.error('getParsedJSON HTTP error:', response.status);
          return null;
        }
        return await response.json();
      } catch (e) {
        console.error('getParsedJSON error:', e);
        return null;
      }
    }

    //時刻を読める形式に変換 引数timeはミリ秒単位
    function getReadableTime(time) {
      const dt = new Date(time);
      const y = dt.getFullYear();
      const m = dt.getMonth() + 1;
      const d = dt.getDate();
      const h = dt.getHours();
      const min = ("0" + dt.getMinutes()).slice(-2);  //「分」のゼロフィル
      return `${y}/${m}/${d} ${h}:${min}`;
    }

    // // 20260209 rainrader 側の仕様変更に対応 
    // 気象レーダーをプロットしたレイヤを返す
    async function getWeatherLayer() {
      // レイヤーを作成
      const weatherJSON = await getParsedJSON('https://api.rainviewer.com/public/weather-maps.json');
      if (!weatherJSON) return null; // JSONの取得に失敗した場合はnullを返す

      const host = weatherJSON.host; //画像サーバーのホスト
      const latestPath = weatherJSON.radar.past[weatherJSON.radar.past.length - 1].path; //最新のデータパス
      const tileSIze = 512; //画像サイズ (256 または 512)
      const colorScheme = 1; //カラースキームID [5]
      const smooth = 1; //平滑化処理 (1: ON, 0: OFF)
      const snow = 1; //雪の表示 (1: ON, 0: OFF)
      const radarUrl = `${host}${latestPath}/${tileSIze}/{z}/{x}/{y}/${colorScheme}/${smooth}_${snow}.png`; //タイルURLの組み立て
      const raderLayer = L.tileLayer(radarUrl, {
        attribution: '<a href="https://www.rainviewer.com/api.html">RainViewer</a>', //出典明記が必要
        opacity: 0.7, //背景地図が見えるよう透明度を調整
        zIndex: 100,
        updateWhenIdle: true,
        updateWhenZooming: false,
        keepBuffer: 4,
        maxZoom: 7,
        bounds: [[20, 122], [50, 153]],
      });

      // 文字列化した時刻を作成
      const timeStr = getReadableTime(weatherJSON.radar.past[weatherJSON.radar.past.length - 1].time * 1000); 

      // レイヤーと時刻を返す
      return [raderLayer, timeStr];
    }

    //地震の情報をプロットしたレイヤを返す
    async function getEQLayer() {
      const regexp = /([+-][\d\.]+)([+-][\d\.]+)[+-]{0,1}([\d\.]+){0,1}\//; //緯度経度・震源の深さを解析する正規表現。震源の深さは含まれない場合もある
      const jmaURL = "https://www.data.jma.go.jp/multi/quake/quake_detail.html?eventID=<EID>&lang=jp";

      //気象庁から地震情報をGET・レイヤ作成
      const json = await getParsedJSON('https://www.jma.go.jp/bosai/quake/data/list.json');
      if(!json) return null; // JSONの取得に失敗した場合はnullを返す
      const eqlayer = L.layerGroup();

      //forで指定時間時間(24時間以内)の震源・震度情報を取り出す
      //最新の地震を最前面に出すため末尾から処理
      for (const [i, eq] of [...json].reverse().entries()) {
        //表示させないデータを読み飛ばし(null, 震度情報でない、24時間以前)
        if (eq === null || eq.ttl != "震源・震度情報") continue;
        const eqDateTime = new Date(eq.at);
        if ((eqDateTime.getTime() + (24 * 60 * 60 * 1000)) < Date.now()) continue;

        //緯度経度・震源の深さを正規表現で分解 match[1]:緯度 [2]:経度 [3]:震源の深さ(メートル)　震源の深さはオプション。
        // 正規表現でマッチしなかった場合はスキップ
        const match = regexp.exec(eq.cod);
        if (match === null) continue;

        //サークルマーカーのオプション
        const cirOpt = { color: "#FFFF00", weight: 0, fillOpacity: .4 };

        //震度は 5+、5-みたいに表示される　計算し難いので数字部分だけ取り出しておく
        //震度により色分け＆半径調整 社内ルール 震度4以上で報告対象(赤)　4未満：黄
        const maxiNum = eq.maxi.replace("+", "").replace("-", "");
        cirOpt["radius"] = maxiNum * 10;
        if (maxiNum >= 4) cirOpt["color"] = "#FF0000";

        //1時間以内に起こった地震は強調
        if ((eqDateTime.getTime() + (60 * 60 * 1000)) > Date.now()) {
          cirOpt["weight"] = (i === json.length -1 ? 5 : 2);     //最新(i==0)の地震はさらに強調(線を太く)
          cirOpt["fillOpacity"] = .2;
        }

        //サークルマーカー追加
        const cMarker = L.circleMarker(L.latLng(match[1], match[2]), cirOpt);
        cMarker.bindTooltip(`
          ${getReadableTime(eqDateTime)} ${(i === json.length - 1 ? "[最新]" : "")}<BR>
          ${eq.anm}　震源の深さ${match[3] / 1000}km<BR>
          マグニチュード:${eq.mag}<BR>
          最大震度:${eq.maxi.replace("+", "強").replace("-", "弱")}
        `);
        cMarker.on("click", () => window.open(jmaURL.replace("<EID>", eq.ctt))); //クリックで詳細を開く
        cMarker.addTo(eqlayer);
      }
      return eqlayer;
    }

    async function init(oldMap){

      //気象レーダーと地震のレイヤを並行して取得
      // データのダウンロードは先に非同期で実施
      const promiseMarkerlist = getParsedJSON("https://script.google.com/macros/s/AKfycbwV1ESN82c9aYcThxu3E0UMEv3I_3sSedDKHKeH59VBdvVyqTE2I4riwlyAv4BkSTw/exec?markerlist=");
      const promiseWeatherRader = getWeatherLayer();
      const promiseEQLayer = getEQLayer();

      //何種類かの地図のtileLayerをbaseMapsオブジェクトに格納し、ブラウザで選べるようにする
      const baseMaps = {};
      //GoogleMap https://gis.stackexchange.com/questions/225098/using-google-maps-static-tiles-with-leaflet
      //lyrs=？ p；地形　s：衛星　y；衛星ハイブリッド
      baseMaps["GoogleMap"] = L.tileLayer('https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
        {
          maxZoom: 20, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
          attribution: "<a href='https://www.google.co.jp/maps/'>GoogleMap</a>"
        });
      baseMaps["GoogleMap(航空写真)"] = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}',
        {
          maxZoom: 20, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
          attribution: "<a href='https://www.google.co.jp/maps/'>GoogleMap</a>"
        });
      //地理院地図の標準地図タイル
      baseMaps["地理院地図"] = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png',
        { attribution: "<a href='https://maps.gsi.go.jp/development/ichiran.html' target='_blank'>地理院タイル</a>" });
      //地理院地図の淡色地図タイル
      baseMaps["淡色地図"] = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png',
        { attribution: "<a href='https://portal.cyberjapan.jp/help/termsofuse.html' target='_blank'>地理院タイル</a>" });
      //オープンストリートマップのタイル
      baseMaps["Open Street Map"] = L.tileLayer('https://tile.openstreetmap.jp/{z}/{x}/{y}.png',
        { attribution: "<a href='https://osm.org/copyright' target='_blank'>OpenStreetMap</a> contributors" });

      // 凡例を右下に追加
      const legend = L.control({ position: 'bottomright' });
      legend.onAdd = function () {
        const div = L.DomUtil.create('div', 'info legend');
        const labels = [];
        labels.push('<span class="legend-item"><span class="legend-item-color" style="background:#0000ff"></span>入局前</span>');
        labels.push('<span class="legend-item"><span class="legend-item-color" style="background:#ff0000"></span>入局中</span>');
        labels.push('<span class="legend-item"><span class="legend-item-color" style="background:#7d7d7d"></span>退局済み</span>');
        labels.push('<span class="legend-item"><span class="legend-item-color" style="background:#ffff00"></span>入退局情報なし</span>');
        // labels.push('<span class="legend-item"><span class="legend-item-color" style="background:#ee7800"></span>凡例:橙</span>');
        // labels.push('<span class="legend-item"><span class="legend-item-color" style="background:#00ff00"></span>凡例:緑</span>');
        div.innerHTML = labels.join('');
        return div;
      };

      // ビル情報のリストを取得
      const markerList = await promiseMarkerlist;
      // //マーカーに表示したい対象の緯度経度とポップアップする名称を設定
      // const markerList = [
      //   // { pos: [34.6686457384369, 135.49130770470023], name: "桜川", icon: grayIcon, layer: "関西" },
      //   // { pos: [35.652103840876286, 139.7980625095375], name: "豊洲", icon: grayIcon, layer: "関東" },
      //   // { pos: [34.711141226058295, 135.6147849221825], name: "大東", icon: grayIcon, layer: "関西" }, 
      // ];

      // markerList取得前に地図を更新すると何も表示されない時間ができるので、ここで現地図の削除、新地図の描画
      if (oldMap) {
        oldMap.remove(); // 地図とそれに紐づくイベントをすべて削除
      }
      const map = L.map('mapcontainer');
      baseMaps["GoogleMap"].addTo(map);   //デフォルトで表示する地図設定
      L.control.scale({ maxWidth: 250, imperial: false }).addTo(map);   //縮尺追加
      legend.addTo(map);    //凡例追加

      //マーカー全体を表示するためのboundを用意
      const bound = L.latLngBounds(markerList[0].pos, markerList[0].pos);

      //連想配列layersに、markerList(各GC情報)のlayer毎にmarkerClusterGroupを格納＆マーカーを追加
      const layers = {};
      for (const mk of markerList) {
        if (!(mk.layer in layers)) {
          //連想配列layersにlayreの要素がない場合、要素追加＆マーカークラスター作成
          layers[mk.layer] = L.markerClusterGroup({
            maxClusterRadius: 0,
          });  //クラスタ化の半径(初期値80)、大きくすると離れたマーカーも1つにまとめます
          if (Object.keys(layers).length == 1) //最初に作成したレイヤだけ地図に表示
            map.addLayer(layers[mk.layer]);    
          //map.addLayer(layers[mk.layer]);    //全レイヤを地図に表示
        }
        layers[mk.layer].addLayer(  //レイヤにマーカーを追加
          L.marker(mk.pos, { icon: mapIcons[mk.icon] }).bindTooltip(mk.name, { permanent: false }).on('click', function () { clickEvt(mk.record); })); //マウスオーバー時のみ表示、マーカークリックで詳細情報へ
        bound.extend(mk.pos);   //boundにマーカーを追加(mk.posが入るように範囲を広げる) 
      }

      // 雨雲レイヤを連想配列layersに追加＆地図に表示
      const weatherData = await promiseWeatherRader;
      if (weatherData){
        const [weatherLayer, timestr] = weatherData;
        const weatherLayerName = `雨雲(${timestr})`; //レイヤ名に時刻をつける
        layers[weatherLayerName] = weatherLayer; // レイヤをマップに追加
        // map.addLayer(layers[weatherLayerName]); // レイヤを選択状態にする
      } 

      // 地震レイヤを連想配列layersに追加＆地図に表示
      const eqlayer = await promiseEQLayer;
      if (eqlayer) {
        layers["地震(震源・過去24h)"] = eqlayer;
        map.addLayer(eqlayer);
      }

      //切り替えBoxを作成( {collapsed:false}で表示しっぱなし)＆マーカーが入るように地図範囲設定
      L.control.layers(baseMaps, layers, { collapsed: false }).addTo(map);
      map.fitBounds(bound);

      //マーカークリック時イベント
      function clickEvt(builName) {
        //window.open('https://maps.google.com/maps?ll=35,135');
        const link = "<?!= builLink ?>".replace(/<BUIL>/g, builName);
        window.open(link, '_blank', 'height=600');
      }
      return map;
    }

    async function refreshMap(currentMap = null){
      console.log('マップをクリアして再読み込みします...: ' + new Date().toLocaleTimeString());
      const nextMap = await init(currentMap);
      setTimeout(() => refreshMap(nextMap), 60*1000); // 60秒ごとに更新
    }
  </script>
  <div id="mapcontainer" style="position:absolute;top:0;left:0;right:0;bottom:0;"></div>
</body>

</html>